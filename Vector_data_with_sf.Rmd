---
title: "Introduction to Spatial Analysis in R"
subtitle: "Vector data and simple features"
author: "Roozbeh Valavi, Jutta Beher and David Wilkinson"
date: "23/07/2019"
output:
  html_document:
    code_folding: show
    depth: 3
    number_sections: no
    theme: yeti
    toc: yes
    toc_float: yes
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
	echo = TRUE,
	message = FALSE,
	warning = FALSE
)
```

# Vector data and features

A feature is thought of as a thing, or an object in the real world, such as a building or a tree. As is the case with *objects*, they often consist of other objects. This is the case with features too: **a set of features can form a single feature**. A forest stand can be a feature, a forest can be a feature, a city can be a feature (by Edzer Pebesma).   


```{r echo=FALSE}
library(sf)

par(bty="l", mfrow=c(2,2))

feature1 <- rbind(c(1, 1.0), c(1.5, 2), c(2, 2), c(2.5, 1.5))
feature2 <- rbind(c(1, 1.0), c(1.5, 2), c(2, 2), c(2.5, 1.5), c(1, 1.0))

st_multipoint(feature1) %>% 
  plot(axes = TRUE, ylim = c(0.5, 2), xlim = c(0.5, 3), main = "Points", cex = 0.7, pch = 16, col = "red")

st_linestring(feature1) %>% 
  plot(axes = TRUE, ylim = c(0.5, 2), xlim = c(0.5, 3), main = "Line")
st_multipoint(feature1) %>% 
  plot(add = TRUE, cex = 0.7, pch = 16, col = "red")

st_polygon(list(feature2)) %>% 
  plot(axes = TRUE, ylim = c(0.5, 2), xlim = c(0.5, 3), main = "Polygon", col = "lightblue")
st_multipoint(feature1) %>% 
  plot(add = TRUE, cex = 0.7, pch = 16, col = "red")

```



# Simple features in R

The definition of **simple features** in [wikipedia](https://en.wikipedia.org/wiki/Simple_Features).   

![](/Users/rvalavi/Dropbox/MyProjects/Intro_Spatial_Analysis_Workshop/images/simple_features.png)

I highly recommed reading [the simple feature web page](https://r-spatial.github.io/sf/articles/sf1.html).

The structure of the data in R is as follow:

![](images/sf_xfig.png)


## sf package

Ths `sf` package provides *simple feature access* for R. The `sf` object is a `data.frame` with a *geometry list-column*. It supports different format and spatial references since it is connected to **GDAL** and **PROJ**.

```{r message=TRUE, warning=TRUE}
# install.packages("sf")
library(sf)

```

```{r message=FALSE, warning=TRUE}


```

# Reading and converting data to sf

You can read files directly to sf or convert them from other object types (e.g. `data.frame` or `sp` objects).

Now, we can read a polygon map of Australia in **shapefile (.shp)**.

```{r eval=FALSE}
states <- st_read("data/Australia/Australia_proj.shp")
states

plot(states)

# plot only the geometry
plot(st_geometry(states))

```

```{r, echo=FALSE}
states <- st_read("data/Australia/Australia_proj.shp", quiet = TRUE)
states

plot(states)

```

```{r}
# plot only the geometry
plot(st_geometry(states))

```

Here we want to read **koala.csv** file into R and convert it to `sf` object. This file contains *longitude* and *latitude* columns that we can use to create `sf` object.

```{r}
# reading csv file
koala <- read.csv("data/koala.csv")
head(koala) # see the first few rows

# convert to sf
koala_sf <- st_as_sf(koala, coords = c("Longitude", "Latitude"), crs = 4326)

plot(koala_sf)

```


## Import data form packages

We can use `rworldmap` package to download the bo9undary map of the world. This packae provides the `SpatialPolygonsDataFrame` object of the world's countries. We can convert it to `sf`. For this purpose we use `dplyr` package and its *piping* functionality to simplify the code!   
Remember to load `dplyr` or `tidyverse` package.

```{r message=FALSE, warning=FALSE}
library(rworldmap)
library(tidyverse)

wmap <- rworldmap::getMap(resolution = "low")  %>% # this is SpatialPolygonDataFrame
  st_as_sf()

plot(wmap["NAME"])

# filter Australia by dplyr
australia <- wmap %>% 
  filter(NAME == "Australia")

# plot only the geomety of asutalia
plot(australia$geometry, axes = TRUE)

```

We can get the cities of Australia from `maps` package.


```{r}
library(maps)

data(world.cities)
head(world.cities)

cities <- st_as_sf(world.cities, coords = c("long", "lat"), crs = 4326) %>% 
  filter(country.etc == "Australia")

plot(cities["pop"])

```

Why they are all the same colour?

```{r}
# filter cities with a population over 1 million
big_cities <- filter(cities, pop > 1e6)

plot(australia$geometry)
plot(big_cities["pop"], cex = big_cities$pop / 1e6, lwd = 2, add = TRUE)

```

# Transform coordinate reference system

Now, we want to put the `koala_sf` on top of `states` map to see where koalas occur!  

What happend?!   

Check the coordinate reference of both maps! Are the same?

```{r}
st_crs(states)

st_crs(koala_sf)

```

Two map layers should have the same spatial reference to be plotted on the correct location relative to each other. For this, we need to change `koala_sf` to be the same as `states`.

Notice, the `crs` argument acsepts the `EPSG` code as well.
   
```{r}
# change the projection
koala_proj <- st_transform(koala_sf, crs = st_crs(states))

# plot both layers
plot(st_geometry(states), axes = TRUE)
plot(koala_proj, col = "blue", add = TRUE)

```

----------

# Challenge one

Load the `Australia_proj` and `koala` data and plot them on top of each other in `Mercator projection`.
Note: check the spatial reference of the maps first!
   
Directory of the data:   
`data/Australia/Australia_proj.shp`   
`data/koala.csv`

----------

# Geometric operations


## Cropping sf

```{r eval=FALSE}
library(raster)

# first plot the map
plot(australia$geometry, axes = TRUE)
# draw extent manually
ext <- drawExtent()

```

![](images/darwExt.jpeg)

```{r echo=FALSE}
ext <- c(xmin = 111.1161,
         xmax = 157.1691,
         ymin = -45.75776,
         ymax = -8.494258 )
```

```{r message=FALSE, warning=FALSE}
australia_clip <- st_crop(australia, ext)
plot(australia_clip$geometry, axes = TRUE)
```

## buffer and join

```{r}
buf <- st_buffer(koala_proj, 1e5)

plot(st_geometry(states))
plot(st_geometry(koala_proj), col = "blue", pch = 16, cex = 0.5, add = TRUE)
plot(st_geometry(buf), border = "red", add = TRUE)

```

Join the buffers

```{r}
buf <- st_buffer(koala_proj, 1.5e5) %>% 
  st_union()

plot(st_geometry(states))
plot(st_geometry(koala_proj), col = "blue", pch = 16, cex = 0.5, add = TRUE)
plot(st_geometry(buf), border = "red", add = TRUE)

```

## Spatial join and intersects

```{r}
koala_states <- st_intersection(koala_proj, states)

table(koala_states$STATENAME)

```


## Nearest distance

Distance to the costline:

```{r}
# change polygon to line
aus_line <- st_cast(australia_clip, "MULTILINESTRING")

koala_sf$coastdist <- as.numeric(st_distance(koala_sf, aus_line))

plot(australia_clip$geometry)
plot(koala_sf["coastdist"], add = TRUE)

```

nearest distance of koalas and it's map colours

```{r}
koala_dist <- st_distance(koala_proj, koala_proj)
head(koala_dist)

mindist <- function(x) {
  mindis <- vector(mode = "numeric", length = nrow(x))
  for(i in 1:nrow(x)){
    mindis[i] <- min(x[i, -i])
  }
  return(mindis)
}

koala_proj$ndist <- mindist(koala_dist)

plot(koala_proj["ndist"])

```



# Write spatial data

To write your spatial vector data in your hard disk, you can use `st_write` function.   

Here we write the `koala_proj` data to [`GeoPackage`](https://www.geopackage.org/) format. `GeoPackage` is an OGC standard, and open format for transferring geospatial information. It is platform-independent, portable, and a compact format.
    
The old and familiar `shapefile` format has some drawbacks. For instance:   

1. It stores in several individual fileds in hard disk
2. Size limitation to 2GB
3. Column names are limited to 12 characters
   

```{r eval=FALSE}

st_write(koala_proj, "data/koala_projected.gpkg")

```

----------

# Challenge two

Load the city maps and calculate the nearest straight distance to the coastline of the cities with 0.5 m population and plot the distance.

----------

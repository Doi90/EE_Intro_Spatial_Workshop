[
["index.html", "Introduction to Spatial Analysis in R 1 Home page", " Introduction to Spatial Analysis in R An Ecology and Evolution PhD Program Workshop Roozbeh Valavi, Jutta Beher, and David Wilkinson 2019-07-29 1 Home page This website hosts the course material for the Ecology and Evolution PhD program’s Introduction to Spatial Analysis in R workshop. "],
["introduction.html", "2 Introduction", " 2 Introduction Please refer to our powerpoint presentation for the introduction material. It can be found on the GitHub repository hosting this website here "],
["vector-data.html", "3 Vector Data 3.1 Vector data and features 3.2 Simple features in R 3.3 sf package 3.4 Transform coordinate reference system 3.5 Challenge one 3.6 Geometric operations 3.7 Write spatial data 3.8 Challenge two", " 3 Vector Data 3.1 Vector data and features A feature is thought of as a thing, or an object in the real world, such as a building or a tree. As is the case with objects, they often consist of other objects. This is the case with features too: a set of features can form a single feature. A forest stand can be a feature, a forest can be a feature, a city can be a feature (by Edzer Pebesma). 3.2 Simple features in R The definition of simple features in wikipedia. The structure of the data in R is as follow: We highly recommed reading the simple feature web page. 3.3 sf package Ths sf package provides simple feature access for R. The sf object is a data.frame with a geometry list-column. It supports different format and spatial references since it is connected to GDAL and PROJ. library(sf) 3.3.1 Reading and converting data to sf You can read files directly to sf or convert them from other object types (e.g. data.frame or sp objects). Now, we can read a polygon map of Australia in shapefile (.shp). states &lt;- st_read(&quot;data/Australia/Australia_proj.shp&quot;) states plot(states) # plot only the geometry plot(st_geometry(states)) ## Simple feature collection with 8 features and 4 fields ## geometry type: POLYGON ## dimension: XY ## bbox: xmin: -2063975 ymin: -4965263 xmax: 1891143 ymax: -1285856 ## epsg (SRID): NA ## proj4string: +proj=lcc +lat_1=-18 +lat_2=-36 +lat_0=0 +lon_0=134 +x_0=0 +y_0=0 +ellps=GRS80 +units=m +no_defs ## STATE STATENAME SHAPE_Leng SHAPE_Area ## 1 9 Western Australia 102.585497 227.4586760 ## 2 5 Queensland 78.230893 151.7205320 ## 3 6 South Australia 61.940128 91.7623310 ## 4 8 Victoria 35.336464 22.9619050 ## 5 1 Australian Capital Territory 2.757198 0.2338955 ## 6 7 Tasmania 21.742202 7.0119035 ## 7 3 New South Wales 52.471221 76.6085725 ## 8 4 Northern Territory 67.244892 115.0931295 ## geometry ## 1 POLYGON ((-869275 -1649846,... ## 2 POLYGON ((1224467 -1789526,... ## 3 POLYGON ((-494224 -2961045,... ## 4 POLYGON ((643286.2 -3849372... ## 5 POLYGON ((1368783 -4037628,... ## 6 POLYGON ((1166744 -4924361,... ## 7 POLYGON ((1587643 -3346985,... ## 8 POLYGON ((285958.2 -1394759... # plot only the geometry plot(st_geometry(states)) Here we want to read koala.csv file into R and convert it to sf object. This file contains longitude and latitude columns that we can use to create sf object. # reading csv file koala &lt;- read.csv(&quot;data/koala.csv&quot;) head(koala) # see the first few rows ## Genus Species Longitude Latitude ## 1 Phascolarctos Phascolarctos cinereus 152.7297 -30.18316 ## 2 Phascolarctos Phascolarctos cinereus 151.8413 -32.79279 ## 3 Phascolarctos Phascolarctos cinereus 152.7621 -30.23195 ## 4 Phascolarctos Phascolarctos cinereus 138.7290 -34.94308 ## 5 Phascolarctos Phascolarctos cinereus 153.5165 -28.58857 ## 6 Phascolarctos Phascolarctos cinereus 153.2155 -27.49284 # convert to sf koala_sf &lt;- st_as_sf(koala, coords = c(&quot;Longitude&quot;, &quot;Latitude&quot;), crs = 4326) plot(koala_sf) 3.3.2 Import data from packages We can use rworldmap package to download the boundary map of the world. This package provides the SpatialPolygonsDataFrame object of the world’s countries. We can convert it to sf. For this purpose we use the dplyr package and its piping functionality to simplify the code! Remember to load dplyr or tidyverse package. library(rworldmap) library(tidyverse) wmap &lt;- rworldmap::getMap(resolution = &quot;low&quot;) %&gt;% # this is SpatialPolygonDataFrame st_as_sf() plot(wmap[&quot;NAME&quot;]) # filter Australia by dplyr australia &lt;- wmap %&gt;% filter(NAME == &quot;Australia&quot;) # plot only the geomety of asutalia plot(australia$geometry, axes = TRUE) We can get the cities of Australia from maps package. library(maps) data(world.cities) head(world.cities) ## name country.etc pop lat long capital ## 1 &#39;Abasan al-Jadidah Palestine 5629 31.31 34.34 0 ## 2 &#39;Abasan al-Kabirah Palestine 18999 31.32 34.35 0 ## 3 &#39;Abdul Hakim Pakistan 47788 30.55 72.11 0 ## 4 &#39;Abdullah-as-Salam Kuwait 21817 29.36 47.98 0 ## 5 &#39;Abud Palestine 2456 32.03 35.07 0 ## 6 &#39;Abwein Palestine 3434 32.03 35.20 0 cities &lt;- st_as_sf(world.cities, coords = c(&quot;long&quot;, &quot;lat&quot;), crs = 4326) %&gt;% filter(country.etc == &quot;Australia&quot;) plot(cities[&quot;pop&quot;]) Why they are all the same colour? # filter cities with a population over 1 million big_cities &lt;- filter(cities, pop &gt; 1e6) plot(australia$geometry) plot(big_cities[&quot;pop&quot;], cex = big_cities$pop / 1e6, lwd = 2, add = TRUE) 3.4 Transform coordinate reference system Now, we want to put the koala_sf on top of states map to see where koalas occur! What happend?! Check the coordinate reference of both maps! Are they the same? st_crs(states) ## Coordinate Reference System: ## No EPSG code ## proj4string: &quot;+proj=lcc +lat_1=-18 +lat_2=-36 +lat_0=0 +lon_0=134 +x_0=0 +y_0=0 +ellps=GRS80 +units=m +no_defs&quot; st_crs(koala_sf) ## Coordinate Reference System: ## EPSG: 4326 ## proj4string: &quot;+proj=longlat +datum=WGS84 +no_defs&quot; Two map layers should have the same spatial reference to be plotted on the correct location relative to each other. For this, we need to change koala_sf to be the same as states or vice versa. Notice, the crs argument acsepts the EPSG code as well. # change the projection koala_proj &lt;- st_transform(koala_sf, crs = 3112) # or koala_proj &lt;- st_transform(koala_sf, crs = st_crs(states)) # plot both layers plot(st_geometry(states), axes = TRUE) plot(koala_proj, col = &quot;blue&quot;, add = TRUE) ## Warning in plot.sf(koala_proj, col = &quot;blue&quot;, add = TRUE): ignoring all but ## the first attribute 3.5 Challenge one Load the Australia_proj and koala data and plot them on top of each other in Mercator projection (EPSG: 4326). Note: check the spatial reference of the maps first! Directory of the data: data/Australia/Australia_proj.shp data/koala.csv 3.6 Geometric operations 3.6.1 Cropping sf You can clip the sf object by another sf object or an extent object. The extent object can come from a layer (st_bbox for sf and extent for rasters) or we can draw one by drawExtent function in the raster package. First, you need to plot a map, then run this function. For drawing the extent you should click on two points in the plotted map. library(raster) # first plot the map plot(australia$geometry, axes = TRUE) # draw extent manually ext &lt;- drawExtent() Now, you can use this object to clip a vector layer. australia_clip &lt;- st_crop(australia, ext) plot(australia_clip$geometry, axes = TRUE) 3.6.2 Buffer and join In many cases, you need to specify a zone around your map features. We can do this with buffer function in GIS and R. In many GIS software, the distance you specify for your buffers is in the unit of the input features (e.g. degree for the latlong coordinates and meters for Lambert or UTM), with an exception of buffer function in raster package. Here we use koala_proj object which is in the Lambert coordinate system, so the unit is in metres. The st_buffer is the function we need here. buf &lt;- st_buffer(koala_proj, 2e5) plot(st_geometry(states)) plot(st_geometry(koala_proj), col = &quot;blue&quot;, pch = 16, cex = 0.5, add = TRUE) plot(st_geometry(buf), border = &quot;red&quot;, add = TRUE) As you see in the plot, for each point in the koala data, a buffer has been created. If the buffer area as a whole is the your purpose and the individual buffers is not important for you, you can use the st_join function to merge all the features in your buffer layer. buf &lt;- st_buffer(koala_proj, 2e5) %&gt;% st_union() plot(st_geometry(states)) plot(st_geometry(koala_proj), col = &quot;blue&quot;, pch = 16, cex = 0.5, add = TRUE) plot(st_geometry(buf), border = &quot;red&quot;, add = TRUE) 3.6.3 Spatial join and intersection Imagine you want to check how many of your koala points fall in each state. This can be done by st_intersection function. Notice that st_intersects function is a similar function, but it does not return a spatial object. With this function, the attribute of the second layer will be joined to the first layer where they have a spatial intersection. This is also called spatial join in GIS. koala_states &lt;- st_intersection(koala_proj, states) ## Warning: attribute variables are assumed to be spatially constant ## throughout all geometries table(koala_states$STATENAME) ## ## Australian Capital Territory New South Wales ## 0 181 ## Northern Territory Queensland ## 0 16 ## South Australia Tasmania ## 14 0 ## Victoria Western Australia ## 31 0 There are a lot of other geometric operations and handy functions to check the topologic relationship of simple features in sf package. To see more examples see the sf package vignettes. 3.6.4 Nearest distance Spatial distance is a very important functionality in spatial analysis. Calculating the distance between features is very easy in GIS. Here we want to calculate the distance between the koala points and Australia coastline. First, we need to convert the Australia map to line object, then calculate the points to the line. This is because the distance of the points to a polygon that contains them is zero. We can do this by st_cast function. To calculate the spatial distance of the points to the line, st_distance function is used. This function returns a dense distance matrix that shows the pairwise distance of every single feature in both datasets. The output object would be in units so we can convert it to numeric. # change polygon to line aus_line &lt;- st_cast(australia_clip, &quot;MULTILINESTRING&quot;) # calculate distance and save it in coastdist column koala_sf$coastdist &lt;- as.numeric(st_distance(koala_sf, aus_line)) plot(australia_clip$geometry) plot(koala_sf[&quot;coastdist&quot;], add = TRUE) Here, the distance matrix is a [250 x 1] matrix (250 koala points and 1 line of coastline). In the cases where there are more several features in both layers, you need to calculate the min of each row of the output matrix (e.g. with apply function). When you want to calculate the nearest distance of every feature in the same layer, you need to repeat the same layer in the st_distance function twice and then calculate the minimum distance. But here is not that easy! Because the nearest distance of every object in the same layer would be itself i.e. the min distance for all of the features would be zero. So, you need to discard the self-distance in the calculating minimum function. You can use the following function to do that. You might be able to find an easier or more efficient way to do that. koala_dist &lt;- st_distance(koala_proj, koala_proj) dim(koala_dist) # dimention of the dist matrix ## [1] 250 250 koala_dist[1:5, 1:5] ## Units: [m] ## [,1] [,2] [,3] [,4] [,5] ## [1,] 0.000 298613.7 6173.952 1404940 190336.9 ## [2,] 298613.686 0.0 294356.980 1229357 487957.8 ## [3,] 6173.952 294357.0 0.000 1405478 194075.2 ## [4,] 1404940.357 1229357.4 1405478.023 0 1552826.2 ## [5,] 190336.917 487957.8 194075.206 1552826 0.0 # function to calculate min distance excluding the self-distance mindist &lt;- function(x) { mindis &lt;- vector(mode = &quot;numeric&quot;, length = nrow(x)) for(i in seq_len(nrow(x))){ mindis[i] &lt;- min(x[i, -i]) } return(mindis) } # calculate min distance and save it in ndist column koala_proj$ndist &lt;- mindist(koala_dist) plot(koala_proj[&quot;ndist&quot;]) 3.7 Write spatial data To write your spatial vector data in your hard disk, you can use st_write function. Here we write the koala_proj data to GeoPackage format. GeoPackage is an OGC standard and open format for transferring geospatial information. It is platform-independent, portable, and a compact format. The old and familiar shapefile format has some drawbacks. For instance: It stores in several individual files in hard disk Size limitation to 2GB Column names are limited to 12 characters st_write(koala_proj, &quot;data/koala_projected.gpkg&quot;) You can read .gpkg format the same way you read .shp files (with st_read function). GeoPackage is supported by GDAL, it means you can read and write them in all (updated) GIS software like QGIS. 3.8 Challenge two Load the city maps and calculate the nearest straight distance to the coastline of the cities with 0.5 m population and plot the distance. Then save the output layer in GeoPackage. "],
["raster-data.html", "4 Raster Data 4.1 Rasters and raster analysis 4.2 Understanding what a raster is 4.3 You can do any maths with a raster! 4.4 Investigate rasters 4.5 Reading a raster into R 4.6 Reading a list of rasters into R 4.7 Challenge One: Operations on raster stacks 4.8 Writing new rasters to file 4.9 Challenge 2: Creating categories from summarizing and combining data 4.10 Preparation for the reclassification into categories: 4.11 Reclassification", " 4 Raster Data 4.1 Rasters and raster analysis In this section you learn what a raster is, and how to read, plot, and manipulate such data. First install the required packages library(rgdal) library(raster) library(tidyverse) library(sf) library(maps) # for making a scale bar library(rgeos) # for labels on polygons Now set the working directory to your own computer (or better yet be using an R project!). setwd(&quot;/Users/juttabeher/Documents/phd_melbourne/workshops/EE_Intro_Spatial_Workshop&quot;) 4.2 Understanding what a raster is What is a raster? Nothing more than a matrix! The command raster() turns any matrix into a raster-object that can be used for spatial analysis. You will now create your own raster: Create an empty matrix with the required dimensions: r &lt;- matrix(0, nrow = 3, ncol = 3) r ## [,1] [,2] [,3] ## [1,] 0 0 0 ## [2,] 0 0 0 ## [3,] 0 0 0 Populate each row of the matrix with information (the values of the cells) and use the raster() command to turn it into a raster object, which you can plot. r[ , 1] &lt;- c(1, 2, 3) r[ , 2] &lt;- c(5, 6, 7) r[ , 3] &lt;- c(8:10) rr &lt;- raster(r) r ## [,1] [,2] [,3] ## [1,] 1 5 8 ## [2,] 2 6 9 ## [3,] 3 7 10 plot(rr) As you can see, every cell has a color according to its value. You will find out later how to select specific colors. 4.3 You can do any maths with a raster! plot(rr * 2) plot(rr * 100) plot(rr + rr) plot(rr - rr) 4.3.1 Optional task: Create a second raster with different numbers, add both rasters up and plot the result. Did the colors change? 4.4 Investigate rasters You can also use these commands to investigate different aspects of the data: res(rr) # returns the cell size dimensions (an x and y value) ## [1] 0.3333333 0.3333333 ncol(rr) # the number of columns ## [1] 3 nrow(rr) # the number of rows ## [1] 3 ncell(rr) # the number of cells (rows * columns) ## [1] 9 dim(rr) # the dimensions of the raster (number of columns, number of rows, number of bands) ## [1] 3 3 1 crs(rr) # the projection of the raster, if it has one ## CRS arguments: NA xmin(rr) # the x and y minimum and maximum coordinates, if there are any ## [1] 0 ymin(rr) ## [1] 0 xmax(rr) ## [1] 1 ymax(rr) ## [1] 1 range(values(rr), # the range of raster values, ignoring NoData na.rm = TRUE) ## [1] 1 10 cellStats(rr, # the mean, min, max, sd, sum mean) ## [1] 5.666667 freq(rr) # for categorical rasters, the frequency of values ## value count ## [1,] 1 1 ## [2,] 2 1 ## [3,] 3 1 ## [4,] 5 1 ## [5,] 6 1 ## [6,] 7 1 ## [7,] 8 1 ## [8,] 9 1 ## [9,] 10 1 4.5 Reading a raster into R Now we use a raster version of the outline of Australia to extract data from the worldclim dataset, and create one layer for mean annual temperature, and mean annual rainfall. The raster() command is used to read in single data objects: au &lt;- raster(&quot;data/australia.tif&quot;) plot(au) Investigate the raster: how many cells does it have? How many rows and columns? Can you calculate how large one cell is? 4.6 Reading a list of rasters into R As useful as single data files are, often you have to read in a lot of files at the same time, for example when working with time series such as climate data that often come in files for single months, days or years and you need to combine or summarise them for your analysis. Instead of reading in every single file individually, you can create stacks. This is particularly useful if you intend to combine them, for example by calculating the annual mean from 12 monthly means. To do so, you can create a list from all files in a directory to read in at once, and then create a stack of rasters, like a thick sandwich. rasterlist_t &lt;- list.files(&quot;data/wc_tavg&quot;, pattern = &quot;.tif$&quot;, full.names = TRUE) head(rasterlist_t) # just a list ## [1] &quot;data/wc_tavg/wc2.0_2.5m_tavg_01.tif&quot; ## [2] &quot;data/wc_tavg/wc2.0_2.5m_tavg_02.tif&quot; ## [3] &quot;data/wc_tavg/wc2.0_2.5m_tavg_03.tif&quot; ## [4] &quot;data/wc_tavg/wc2.0_2.5m_tavg_04.tif&quot; ## [5] &quot;data/wc_tavg/wc2.0_2.5m_tavg_05.tif&quot; ## [6] &quot;data/wc_tavg/wc2.0_2.5m_tavg_06.tif&quot; t_stack &lt;- stack(rasterlist_t) plot(t_stack) # you should see that there are 12 rasters Now do the same for the rainfall data! #don&#39;t show code rasterlist_p &lt;- list.files(&quot;data/wc_prec&quot;, pattern = &quot;.tif$&quot;, full.names = TRUE) p_stack &lt;- stack(rasterlist_p) 4.7 Challenge One: Operations on raster stacks Now you can use any command you want ONCE on this big sandwich of rasters instead of having to use it 12 times on the single files. You can also line up several commands the you want to execute one after the other, which saves you from generating a lot of intermediary files. The %&gt;% (pipe command) works like that: after the first command is executed, the output gets used for the second command without assigning it to variable and storing it in memory. For example, clipping a raster is a two step process. First, the raster gets cropped to the rectangular extent of the data file used for the clipping (crop function), and then all the cells that have no values in the data file WITHIN the square extent that is used for the clipping are set to NoData (mask function). You can check out if you can see the difference in the output if you don’t use the mask command, there are some parts around the coastline of Australia that will have data without the mask. Can you find them? A single step operation would be like this: t_stack_crop &lt;- crop(t_stack, au) t_stack_crop_mask &lt;- mask(t_stack_crop, au) plot(t_stack_crop_mask) You can speed things up with a pipe: t_stack_au &lt;- crop(t_stack, au) %&gt;% mask(au) p_stack_au &lt;- crop(p_stack, au) %&gt;% mask(au) plot(p_stack_au) Now you can calculate the mean from your cropped and masked stack: pmean &lt;- mean(p_stack_au) tmean &lt;- mean(t_stack_au) You can use the plot() command to check how your output looks or get a summary by executing the name of your new raster. plot(tmean) plot(pmean) Well done, you have mastered single rasters, raster stacks and creating new information from your data! Keep in mind: the data from worldclim is of high quality, and all rasters are already in the same projection and resolution, so you can skip any exploration and preparation of the data. If your data comes from different sources, or you are not sure about the quality, always spend some time with exploration, cleaning and preparing, like omitting obvious wrong points like koalas that are not on land, or investigating NA values (what value is used for NAs (some raster data uses for example -999 or very small values), where are these NAs located, and how might this impact your analysis). 4.8 Writing new rasters to file You can write your new data to file if you want. writeRaster(tmean, filename = &quot;tmean.tif&quot;, format = &quot;GTiff&quot;, overwrite = TRUE) 4.9 Challenge 2: Creating categories from summarizing and combining data In many cases, continuous data is what you want, but sometimes categories are more useful to get a broader overview, or with known thresholds or ranges. Some species for example only occur above a certain temperature, or in a particular elevation. Here you learn how to make categories from combining multiple continuous datasets: You want to make categories for the temperature and the rainfall to get a better overview of distinct combinations. For this exercise, create four categories for temperature (cold, cool,warm, hot) and two for rainfall (dry and wet). Tip: use the cellStats(x, stats) command to find out the quantiles as boundaries for temperature and min, mean, max as boundaries for the rainfall. Of course, the breakpoints that you choose will drive the quality of your results, and to derive at the values at which you want to distinguish categories might need a lot of research or knowledge. You could probably question if the words cold, cool, warm and hot fit to the quantiles. Feel free to try other breakpoints that you find more appropriate. 4.10 Preparation for the reclassification into categories: Maybe you can remember how we created our first raster in the beginning - you will now create such a raster to use for reclassification. It has to show the start and endpoints for your categories (that you found out with cellStats() or based on more meaningful ecological knowledge), as well as the numbers you want to use as category-names: tcat &lt;- matrix(0, nrow = 4, ncol = 3) # populate each row of the matrix with reclassification information for temperature tcat[ , 1] &lt;- c(4, 19, 22, 25) # fill in here the start of the categories tcat[ , 2] &lt;- c(19, 22, 25, 30) # fill in here the endpoint of the categories tcat[ , 3] &lt;- c(1:4) # fill in here the number for the categories (1-4) pcat &lt;- matrix(0, nrow = 2, ncol = 3) # populate each row of the matrix with reclassification information for precipitation pcat[ , 1] &lt;- c(6, 40) pcat[ , 2] &lt;- c(40, 380) pcat[ , 3] &lt;- c(1:2) 4.11 Reclassification Now you can use the matrix for reclassification. Reclassification means that a raster will get overwritten with new values in all cells, based on bins of values. You just created these bins with your matrix. For example, all cells between 4 and 19 degrees will get assigned to category 1 in the new raster. tcat_au &lt;- reclassify(tmean, rcl = tcat, right = FALSE, overwrite = TRUE) pcat_au &lt;- reclassify(pmean, rcl = pcat, right = FALSE, overwrite = TRUE) # check out what you created plot(tcat_au) plot(pcat_au) Now you can combine the 2 rasters to get 8 categories for combinations of temperature and rainfall… Think about it: you want to make sure that you can still see both, the values that describe the rainfall (1 &amp; 2), and the values that describe temperature (1-4). In order to be able to tell them apart, you can multiply one raster by 10 before combining them - that way you will get a combinatory value with 2 digits: one slot has a 1 or 2, and one slot a 1, 2, 3 or 4. What would happen if you just add both rasters up? You can also define the colors you want for your categories. There are many websites that show colors and their names for R. climate_au &lt;- tcat_au + pcat_au * 10 plot(climate_au) # you can select colors for your gradients # define the list of colour names (see Appendix for colour names) colors &lt;- c(&quot;white&quot;, &quot;yellow&quot;, &quot;lightgreen&quot;, &quot;darkgreen&quot;, &quot;lightblue&quot;, &quot;blue&quot;, &quot;purple&quot;, &quot;red&quot;) breaks &lt;- c(10, 11, 12, 13, 14, 21, 22, 23, 24) # plot the raster plot(climate_au, breaks = breaks, col = colors) "],
["combining-vector-and-raster-data.html", "5 Combining Vector and Raster Data 5.1 Challenge 1: Which climate do koalas like? 5.2 Challenge 2: Extract rasters to polygons: how to summarize more complex extractions. 5.3 Attach the new information to your shapefile 5.4 Count points in polygons", " 5 Combining Vector and Raster Data For most spatial analysis you are interested in the relationship between several layers. Sometimes you need to combine only raster layers, sometimes raster and vector data, sometimes you only work in the vector world. Here are three examples of possible combinations, but of course there are many more (For example ESRI (the company behind ARC-GIS) have an extensive online help that explains many concepts and tools with text and pictures). Now we want to find out 3 things: 1. How many koalas are in which temperature zone? (vector (point) &amp; raster) 2. How are the temperature zones distributed across the states? (vector (polygon) &amp; raster) 3. How many koalas are in which state? (vector (point) and vector (polygon)) To find out, we have to intersect the two different layers with each other to find out how they relate to each other. This can be done with the command extract() from the raster package. In case you have not done so, read in the shapefile of the Australian states. Data: you will need to have worked through the raster part in order to have the raster with the climate categories. Of course you can try the exercise with any other raster data you are interested in. Feel free to download other species or climate information from online repositories like ALA, OBIS, or worldclim. states &lt;- st_read(&quot;data/AU_states.shp&quot;) ## Reading layer `AU_states&#39; from data source `C:\\Users\\wilko\\Documents\\University\\EE_Intro_Spatial_Workshop\\data\\AU_states.shp&#39; using driver `ESRI Shapefile&#39; ## Simple feature collection with 8 features and 15 fields ## geometry type: POLYGON ## dimension: XY ## bbox: xmin: 113.156 ymin: -43.637 xmax: 153.635 ymax: -10.69 ## epsg (SRID): NA ## proj4string: +proj=longlat +ellps=GRS80 +no_defs states1 &lt;- readOGR(&quot;data/AU_states.shp&quot;) # this is an alternative to read in vector data, some other commands do not work with st objects (see mapping challenge) ## OGR data source with driver: ESRI Shapefile ## Source: &quot;C:\\Users\\wilko\\Documents\\University\\EE_Intro_Spatial_Workshop\\data\\AU_states.shp&quot;, layer: &quot;AU_states&quot; ## with 8 features ## It has 15 fields ## Integer64 fields read as strings: OBJECTID PLANIMETRI SYMBOL as(states, &quot;Spatial&quot;) ## class : SpatialPolygonsDataFrame ## features : 8 ## extent : 113.156, 153.635, -43.637, -10.69 (xmin, xmax, ymin, ymax) ## coord. ref. : +proj=longlat +ellps=GRS80 +no_defs ## variables : 15 ## names : OBJECTID, FEATURETYP, STATE, FEATUREREL, ATTRIBUTER, PLANIMETRI, SOURCE, UFI, CREATIONDA, RETIREMENT, PID, SYMBOL, STATENAME, SHAPE_Leng, SHAPE_Area ## min values : 1, mainland, 1, NA, NA, 0, NA, FF00010107, NA, NA, 0, 0, Australian Capital Territory, 2.757198, 0.2338955 ## max values : 8, mainland, 9, NA, NA, 0, NA, FF00010193, NA, NA, 0, 0, Western Australia, 102.585497, 227.4586760 plot(states[&quot;STATE&quot;]) states1 &lt;- readOGR(&quot;data/AU_states.shp&quot;) # this is an alternative to read in vector data, some other commands do not work with st objects (see mapping challenge) ## OGR data source with driver: ESRI Shapefile ## Source: &quot;C:\\Users\\wilko\\Documents\\University\\EE_Intro_Spatial_Workshop\\data\\AU_states.shp&quot;, layer: &quot;AU_states&quot; ## with 8 features ## It has 15 fields ## Integer64 fields read as strings: OBJECTID PLANIMETRI SYMBOL 5.1 Challenge 1: Which climate do koalas like? When we extract data to points, each point will fall within one cell, so we don’t have to worry about summarizing data. If you have not done so yet, read in the koala data again. You also want to check if they are in the same coordinate reference system before you do you analysis. # reading csv file koala &lt;- read.csv(&quot;data/koala.csv&quot;) # convert to sf koala_sf &lt;- st_as_sf(koala, coords = c(&quot;Longitude&quot;, &quot;Latitude&quot;), crs = 4326) crs(koala_sf) ## [1] &quot;+proj=longlat +datum=WGS84 +no_defs&quot; crs(climate_au) # although this one is slightly longer, they are actually the same. Check out for example the EPSG website, or spatialreference.org to find out more ## CRS arguments: ## +proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0 st_crs(koala_sf) &lt;- crs(climate_au) # if they are the same, but spelled differently, or one is not defined, you can assign the crs of one layer to the other. koala_climate &lt;- raster::extract(climate_au, koala_sf, na.rm = TRUE) Note: sometimes, the name of a function exists in more than one package. Here, the function extract() also exists in the tidyverse. In order to tell R which one you want to use, you can specify with package::function(). You can try out what happens when you just try to use extract(). Check your results: Are there NA values? Why do you think there are NA values? Which climate do koalas like? Often, a simple plot is more informative than a map. hist(koala_climate) 5.2 Challenge 2: Extract rasters to polygons: how to summarize more complex extractions. When you extract data to polygons, like the states of Australia, you potentially have a lot of different values within each state, so we have to decide what we want to do with these values Note: if your vector data is not an sf-object, you might need to use spTransform instead of st_transform when reprojecting, because some packages only talk to a specific data format and can’t work with others. crs(states) ## [1] &quot;+proj=longlat +ellps=GRS80 +no_defs&quot; crs(climate_au) ## CRS arguments: ## +proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0 states_pr &lt;- st_transform(states, crs(climate_au)) state_climate &lt;- raster::extract(climate_au, states_pr, factors = TRUE, df = TRUE, na.rm = TRUE) Now we want to sum up all cells within each state for each category class.counts &lt;- as.data.frame(table(state_climate$ID,state_climate$layer)) What does your output look like if you don’t use the as.data.frame() command? Why do you think it is more useful as a data.frame? How would it be even more useful? 5.3 Attach the new information to your shapefile To be able to use your new information in a map, we join our results onto our shapefile as new columns. This is slightly more advanced, so don’t worry if you don’t get this bit quite yet. table() gives you a summary overview for two parameters, but it is not accessible like other forms (like data.frame or matrix) in R, so it might be a bit tricky to attach it directly to an existing table. By transforming the results from table() into another format you make your life easier. When you want to join columns to an existing table and want to make sure that you don’t mess up the order, you can use a shared column for matching lines up with each other. So a bit of preparation is needed to get the results from table() ready for a join to the spatial data: class.counts &lt;- table(state_climate$ID, state_climate$layer) %&gt;% as.matrix.data.frame() %&gt;% as.data.frame() %&gt;% setNames(paste0(&quot;class_&quot;, c(11, 12, 13, 14, 21, 22, 23, 24))) class.counts$OBJECTID &lt;- as.numeric(rownames(class.counts)) # 1:8 not recommended states_pr &lt;- left_join(states_pr, class.counts, by = &quot;OBJECTID&quot;) Now we can create maps that show the cell count of the different climate categories in each state. You can plot single maps, or a combination plot(states_pr[&quot;class_14&quot;]) plot(states_pr[19:22]) 5.4 Count points in polygons (This is more or less what you already did in the vector part and just here for the sake of completion) We can also count how many Koalas are in each state, and attach the information in the attribute table of the states: state_koala &lt;- st_intersection(koala_sf, states_pr) ## although coordinates are longitude/latitude, st_intersection assumes that they are planar ## Warning: attribute variables are assumed to be spatially constant ## throughout all geometries state.counts &lt;- as.data.frame(table(state_koala$STATENAME, state_koala$Species)) states_pr$koala_count &lt;- state.counts$Freq print(state.counts) ## Var1 Var2 Freq ## 1 Australian Capital Territory Phascolarctos cinereus 0 ## 2 New South Wales Phascolarctos cinereus 181 ## 3 Northern Territory Phascolarctos cinereus 0 ## 4 Queensland Phascolarctos cinereus 16 ## 5 South Australia Phascolarctos cinereus 14 ## 6 Tasmania Phascolarctos cinereus 0 ## 7 Victoria Phascolarctos cinereus 31 ## 8 Western Australia Phascolarctos cinereus 0 If you don’t always work with package sf, and you still want to be really sure that things that you calculated will get filled in the right columns and rows, you can always do a merge: states2 &lt;- merge(states1, state.counts, by.x = &quot;STATENAME&quot;, by.y = &quot;Var1&quot;, sort = TRUE) head(states2@data) ## STATENAME OBJECTID FEATURETYP STATE FEATUREREL ## 8 Western Australia 1 mainland 9 &lt;NA&gt; ## 4 Queensland 2 mainland 5 &lt;NA&gt; ## 5 South Australia 3 mainland 6 &lt;NA&gt; ## 7 Victoria 4 mainland 8 &lt;NA&gt; ## 1 Australian Capital Territory 5 mainland 1 &lt;NA&gt; ## 6 Tasmania 6 mainland 7 &lt;NA&gt; ## ATTRIBUTER PLANIMETRI SOURCE UFI CREATIONDA RETIREMENT PID SYMBOL ## 8 &lt;NA&gt; 0 &lt;NA&gt; FF00010129 &lt;NA&gt; &lt;NA&gt; 0 0 ## 4 &lt;NA&gt; 0 &lt;NA&gt; FF00010169 &lt;NA&gt; &lt;NA&gt; 0 0 ## 5 &lt;NA&gt; 0 &lt;NA&gt; FF00010107 &lt;NA&gt; &lt;NA&gt; 0 0 ## 7 &lt;NA&gt; 0 &lt;NA&gt; FF00010178 &lt;NA&gt; &lt;NA&gt; 0 0 ## 1 &lt;NA&gt; 0 &lt;NA&gt; FF00010181 &lt;NA&gt; &lt;NA&gt; 0 0 ## 6 &lt;NA&gt; 0 &lt;NA&gt; FF00010193 &lt;NA&gt; &lt;NA&gt; 0 0 ## SHAPE_Leng SHAPE_Area Var2 Freq ## 8 102.585497 227.4586760 Phascolarctos cinereus 0 ## 4 78.230893 151.7205320 Phascolarctos cinereus 16 ## 5 61.940128 91.7623310 Phascolarctos cinereus 14 ## 7 35.336464 22.9619050 Phascolarctos cinereus 31 ## 1 2.757198 0.2338955 Phascolarctos cinereus 0 ## 6 21.742202 7.0119035 Phascolarctos cinereus 0 Of course there are many more ways to analyse raster and vector data, this was just a first taste of common operations. Don’t forget: there are usually many different ways (including different packages and commands) to get to the same result. Public forums like stackoverflow offer a way to find alternative ways and also post specific questions when you get stuck. Don’t be shy! It is usually also a good idea to run some tests on a small dataset or subset where you can check manually that you get the result that you want and all numbers make sense. "],
["plotting-in-base-r.html", "6 Plotting in Base R 6.1 Challenge 1: Make a simple map", " 6 Plotting in Base R You will use the basic R plotting to make a map showing climate categories, country and state outlines and points for koalas observations and then save the map to a png file Data: output from raster and interaction section are used 6.1 Challenge 1: Make a simple map # plot to set extent par(mar = c(2,2,2,2)) plot(climate_au, legend = FALSE, col = colors, main = &quot;Koala occurrence in different states and climates&quot;, key.pos = NULL) # plot with colors for levels of factor (filled / outline) # add the state outlines plot(states2, add = TRUE, col = NA, border = &quot;red&quot;)# play with col and border! polygonsLabel(states2, labels = states2$Freq, method = &quot;centroid&quot;, col = &quot;red&quot;) ## [,1] [,2] ## [1,] 122.1843 -25.47049 ## [2,] 144.5335 -22.57526 ## [3,] 135.8241 -30.07906 ## [4,] 144.2959 -36.84460 ## [5,] 149.0022 -35.48869 ## [6,] 146.5946 -42.02384 ## [7,] 147.0159 -32.17495 ## [8,] 133.3700 -19.48190 plot(koala_sf, add = TRUE, pch = 10) #,cex is a rough SHOULD WE ADD A COLUMN FOR E.G. male/female to have them add color categories? ## Warning in plot.sf(koala_sf, add = TRUE, pch = 10): ignoring all but the ## first attribute # way to change the size of symbols or text, pch sets the symbol, feel free to play around #map.axes(cex.axis=0.8) # here cex specifies font size # only needed if not there yet maps::map.scale(120, -40, relwidth = 0.25, metric = TRUE, ratio = FALSE, cex = 0.6) # exchange TRUE and FALSE to see what they colors &lt;- c(&quot;white&quot;, &quot;yellow&quot;, &quot;lightgreen&quot;, &quot;darkgreen&quot;, &quot;lightblue&quot;, &quot;blue&quot;, &quot;purple&quot;, &quot;red&quot;) leg &lt;- c(&quot;dry cold&quot;, &quot;dry cool&quot;, &quot;dry warm&quot;, &quot;dry hot&quot;, &quot;wet cold&quot;, &quot;wet cool&quot;, &quot;wet warm&quot;, &quot;wet hot&quot;)# c(11,12,13,14,21,22,23,24) par(xpd = NA) # to enable to plot outside of plotting area legend(155, y = -15, legend = leg, fill = colors) "],
["plotting-in-ggplot2.html", "7 Plotting in ggplot2 7.1 Creating high quality graphics 7.2 Grammar of Graphics 7.3 Plotting spatial data in ggplot", " 7 Plotting in ggplot2 7.1 Creating high quality graphics Once you’ve completed your spatial data analysis you’re going to need to visualise it in some really nice figures for publication and/or presentations. While you can create plots through various ways, including base R, the most popular method of producing fancy figures is with the ggplot2 package. You can plot raster and vector spatial data with ggplot2. Vector data represent geographical phenomena by points, lines and polygons. Raster is another representation of spatial data that consist of pixels. First things first, if you haven’t done so yet, we need to install the ggplot2 package. You can install tidyverse package that is a collection of packages including ggplot2. install.packages(&quot;tidyverse&quot;) 7.2 Grammar of Graphics ggplot2 is built on the grammar of graphics concept: the idea that any plot can be expressed from the same set of components: 1. A data set 2. A coordinate system 3. A set of geoms - the visual representation of data points The key to understanding ggplot2 is thinking about a figure in layers. To start with we need to create the base layer for our plot. This is done with the ggplot() function, and it is here we define our data and coordinate system components. We set our data component using the data argument, and then use the aesthetic function aes() as a second argument to define our coordinate system. The aes() function can potentially be used multiple times when constructing our figure, so it is important to know that anything defined inside the base ggplot() function is a global option inherited by all subsequent layers. # loading the libraries library(sf) library(raster) library(tidyverse) # this includes ggplot library(viridis) # for colour scheme 7.3 Plotting spatial data in ggplot # loading world map library(rworldmap) wmap &lt;- rworldmap::getMap(resolution = &quot;low&quot;) %&gt;% st_as_sf() 7.3.1 Plotting vector data Plotting vector data with sf is very easy! You only need to provide the data with a sf object and use geom_sf. No need to specify x and y coordinates. ggplot(data = wmap) + geom_sf() Now, the colour and background can be changed. ggplot(data = wmap) + geom_sf(aes(fill = NAME)) + theme_minimal() + guides(fill = FALSE) # don&#39;t show legend 7.3.2 Different spatial reference in plotting Use coord_sf to specify the projection that map is going to be plotted with. # see the coordinate system string st_crs(3035) ## Coordinate Reference System: ## EPSG: 3035 ## proj4string: &quot;+proj=laea +lat_0=52 +lon_0=10 +x_0=4321000 +y_0=3210000 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs&quot; ggplot(data = wmap) + geom_sf() + theme_minimal() + coord_sf(crs = 3035) You can aslo change the colour of background. # read Australia polygon shapefile au &lt;- st_read(&quot;data/AU_states.shp&quot;, quiet = TRUE) ggplot(data = au) + geom_sf(size = 0.3, fill = &quot;white&quot;) + # change the line size and polygon colours theme_minimal() + coord_sf(crs = 3112) + theme(panel.background = element_rect(fill = &quot;steelblue2&quot;)) 7.3.3 Plotting raster data Raster can be large files containing millions of pixels. When you plot this data, the computer can not visualise all the details in the data. Plotting with full dataset could also be time-consuming. To plot rasters, it’s better to get a large sample of the data, then plot it. If the sample is large enough, the plotting quality won’t decrease. # read Australia polygon shapefile au &lt;- st_read(&quot;data/AU_states.shp&quot;, quiet = TRUE) # reading raster data and clip and mask it for Australia au_temp &lt;- raster(&quot;data/wc_tavg/wc2.0_2.5m_tavg_01.tif&quot;) %&gt;% crop(au) # regular sample of 500k cells sam &lt;- sampleRegular(au_temp, size = 5e5, asRaster = TRUE) %&gt;% as.data.frame(xy = TRUE, na.rm = TRUE) %&gt;% setNames(c(&quot;x&quot;, &quot;y&quot;, &quot;layer&quot;)) head(sam) ## x y layer ## 190 122.9583 -10.73417 27.67500 ## 191 123.0100 -10.73417 27.57143 ## 192 123.0616 -10.73417 27.39091 ## 193 123.1133 -10.73417 26.88400 ## 194 123.1650 -10.73417 26.35200 ## 195 123.2167 -10.73417 26.38800 ggplot(data = sam, aes(x = x, y = y, fill = layer)) + geom_raster() You can change the colour and other parametrs of the plot to make it better. It is important to use coord_sf or coord_fixed to keep the dimention of the plot fixed. ggplot(data = sam, aes(x = x, y = y, fill = layer)) + geom_raster() + scale_fill_viridis(option = &quot;A&quot;) + labs(x = &quot;Longitude&quot;, y = &quot;Latitude&quot;, fill = &quot;Temperature&quot;) + coord_sf(crs = 4326) + theme_bw() "]
]
